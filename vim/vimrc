"permet de ne pas encombrer le dossier maison
set undodir=$XDG_DATA_HOME/vim/undo
set directory=$XDG_DATA_HOME/vim/swap
set backupdir=$XDG_DATA_HOME/vim/backup
set viminfo+='1000,n$XDG_DATA_HOME/vim/viminfo
set runtimepath=$XDG_CONFIG_HOME/vim,$VIMRUNTIME,$XDG_CONFIG_HOME/vim/after
set packpath=$XDG_CONFIG_HOME/vim/pack

"Active les plugins
execute pathogen#infect()
set encoding=utf-8

"permet de connaitre sa position
set ruler

"permet d'activer la coloration syntaxique
syntax enable

"Configure la liste des thèmes
function ThemeList(themeNumber)
    if a:themeNumber == 0
        "dark (default)
        set background=dark
        colorscheme dark-meadow 
    elseif a:themeNumber == 1
        "light
        set background=light
        colorscheme pencil
    elseif a:themeNumber == 2
        set background=dark
        colorscheme hashpunk-lapis
    elseif a:themeNumber == 3
        set background=dark
        colorscheme photon
    else
        call ThemeList(0)
    endif
endfunction

"Change theme on the fly
function CycleTheme()
    let g:MyThemeCount = (g:MyThemeCount + 1) % 4
    call ThemeList(g:MyThemeCount)
endfunction
nnoremap <F3> :call CycleTheme()<Enter>:echom g:colors_name<Enter>
let g:MyThemeCount=-1 "Goes to default
call CycleTheme()

"Change spell checking on the fly
let g:spellCount = 0
function ToogleSpell()
    let g:spellCount = g:spellCount + 1
    let l:trueNumber = g:spellCount % 3
    if l:trueNumber == 0
        set nospell
        echom "No spell checking"
    elseif l:trueNumber == 1
        set spell spelllang=en_us
        echom "English spell checking"
    else
        set spell spelllang=fr
        echom "French spell checking"
    endif
endfunction
nnoremap <F4> :call ToogleSpell()<Enter>

"Add or remove a color line
let g:colorColumnCount = 0
function ToogleColorColumn()
    let g:colorColumnCount = g:colorColumnCount + 1
    let l:trueCount = g:colorColumnCount % 4
    if l:trueCount == 0
        set colorcolumn=
        echom "Color column disbled"
    elseif l:trueCount == 1
        set colorcolumn=80
        echom "Color column at 80 column"
    elseif l:trueCount == 2
        set colorcolumn=50
        echom "Color column at 50 column"
    else
        set colorcolumn=100
        echom "Color column at 100 column"
    endif
endfunction
nnoremap <F6> :call ToogleColorColumn()<Enter>

"controle le nombre de charactère que font les TAB
set tabstop=4

"permet d'être plus sur d l'utilisation continue des espaces
set softtabstop=4

"écrit des espaces quand on fait tab
set expandtab  

"permet une inentation intéligente
set shiftwidth=4

"indique le numéro de la ligne
set number
set norelativenumber "Par default, force le mode non relatif
nnoremap <C-n> :set relativenumber!<Cr>

"surligne les recherches
set hlsearch

"assure que le backspace marche
set backspace=indent,eol,start

"affiche les longue lignes sur plusieur lignes
set wrap

" use 256 colors in terminal
if !has("gui_running")
    set t_Co=256
    set term=screen-256color
endif

"permet d'utiliser des  .vimrc locaux à un dossier tout en empéchant vim de faire des trucs louches avec des comandes
set exrc
set secure

"permet d'utiliser des plugins specifiques à certain types de fichier
filetype plugin on

"considère les .h comme du c et pas du c++
augroup project
    autocmd!
    autocmd BufRead,BufNewFile *.h,*.c set filetype=c
    autocmd BufRead,BufNewFile *.nelua set filetype=lua
augroup END

"permet d'utiliser le clipboard général
vnoremap <C-c> "+y
inoremap <C-v> <Esc>"+P

"permet d'avoir des racourssis clavier normaux
noremap <C-s> <Esc>:w<Cr>
inoremap <C-s> <Esc>:w<Cr>a
noremap <C-q> <Esc>:q<Cr>
inoremap <C-q> <Esc>:q<Cr>
"Je n'autorise pas les do et undo en inserion car je ne peut pas limiter ces
"actions à un seul mot
"inoremap <C-z> <Esc>ua
"inoremap <C-y> <Esc><C-r>a
nnoremap <C-z> <Esc>u
nnoremap <C-y> <C-r>
inoremap <C-a> <Esc>gg0vG$
"Récupère les fonctions du Ctrl-V avec Ctrl-R
inoremap <C-R> <C-V>
"Insert a raw tab with Ctrl-T
inoremap <C-T> <C-V><Tab>
"case insensitive search
nnoremap <C-f> /\c
inoremap <Esc><C-f> /\c
"stop search
inoremap <C-g> <Esc>:noh<Cr>:echom "Search cleared."<Cr>i
noremap <C-g> :noh<Cr>:echom "Search cleared."<Cr>
"Omega
inoremap <C-O> Ω
inoremap <C-P> ω
"œ
inoremap <C-O><C-E> œ
" Remove anoying history popup
nnoremap q: :q
nnoremap Q: q:
" Rainbow parenthesis
nnoremap <F7> :RainbowParenthesesToggle<Cr>:RainbowParenthesesLoadSquare<Cr>:RainbowParenthesesLoadBraces<Cr>:RainbowParenthesesLoadChevrons<Cr>

" Tabs
function SwapLeading(from, to)
    let l:i = 9
    while i >= 0
        let l:exec = "silent! %s/\\(" . a:from . "\\)\\{"  . l:i . "\\}\\(" . a:from . "\\)/"
        let l:j = 0
        while l:j < l:i
            let l:exec = l:exec . a:from
            let l:j = l:j + 1
        endwhile
        let l:exec = l:exec . a:to . "/"
        execute l:exec
        let l:i = l:i - 1
    endwhile
endfunction
nnoremap <F5><Space> mt:call SwapLeading("	", "    ")<Cr>'t
nnoremap <F5><Tab> mt:call SwapLeading("    ", "	")<Cr>'t

"empèche les bips en tty
set visualbell

"utilise l'espace en tant que leader
let mapleader = " "

"s'assure que les ftplugin marchent
filetype plugin indent on 

"contrôle de la souris
set mouse=a

"Arrete d'utiliser Esc pour quiter le mode insertion
inoremap kj <esc>

"Status line
set laststatus=2               "Always visible
set statusline=%f\ -\ %Y\ %r\  "Left side (name and type)
set statusline+=%=             " Switch to the right side
set statusline+=%l\ %c%V\ %P   "Right side (Position)

" DevzatCopy, a command to copy the buffer in a way that is pastable on devzat
function DevzatCopy_fnc()
    %s/$/\\n/
    %s/\n//
    normal I```\nkjA```kjV"+yu
    echom "Copied the buffer to be pasted on devzat."
endfunction

command DevzatCopy :call DevzatCopy_fnc()

" Whitespace characters
set listchars=eol:↵,tab:⇤-⇥,trail:○,extends:>,precedes:<,space:·,nbsp:●
noremap <F8> :set list!<CR>
inoremap <F8> <Esc>:set list!<CR>a

" Auto cut to vertical ruller

" Tell if the current line is longuer than the given argument
function IsLineLonguer(len)
    let l:pos = getcurpos()
    let l:pos[2] = a:len + 1
    call setpos(".", l:pos)
    let l:pos = getcurpos()[2]
    return l:pos > a:len
endfunction

" Cut a line in multiple lines that are shorter than the given argument
" Cut line at spaces
function CutToLen(len)
    while IsLineLonguer(a:len)
        exec "normal hF r\n"
    endwhile
endfunction
    
" Cut to the shortest vertical ruller
function CutToRuller()
    let l:len = &colorcolumn + 1 - 1
    call CutToLen(l:len)
endfunction

nnoremap <leader><F6> :call CutToRuller()<Cr>
